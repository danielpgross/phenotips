package org.phenotips.studies.family.internal;

import java.util.*;

import org.apache.commons.lang3.NotImplementedException;
import org.apache.commons.lang3.StringUtils;
import org.apache.zookeeper.KeeperException;

/**
 * Tools for updating the SVG generated by the pedigree.
 */
public class SvgUpdater {
    private static final int PATIENT_ID_LENGTH = 8;

    /**
     * The number of pixels to shift text when a link is removed.
     */
    private static final int VERTICAL_SHIFT = -22;

    private static final String STROKE_ATTR_TOKEN = "stroke-width=\"";

    public static String removeLinks(String svg, String currentPatientId) {
        // must be a list, so that the iterator will return links in order they occur
        List<SvgElementHolder> links =
                SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgLinkParser());
        Iterable<SvgElementHolder> labels =
                SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgTextParser());

        links = SvgUpdater.filterByCurrentPatient(links, currentPatientId, true);
        labels = SvgUpdater.synchronizeOnNodeIds(labels, links);
        svg = SvgUpdater.applyActionToSvg(links.iterator(), new SvgRemoveAction(), svg, labels);

        labels = SvgUpdater.findAgain(labels, svg);
        labels = SvgUpdater.shiftSvgElements(labels, SvgUpdater.VERTICAL_SHIFT);
        svg = SvgUpdater.applyActionToSvg(labels.iterator(), new SvgUpdateAction(), svg);
        return svg;
    }

    /**
     * @param elements must be unaltered
     */
    private static List<SvgElementHolder> findAgain(Iterable<SvgElementHolder> elements, String svg)
    {
        List<SvgElementHolder> found = new LinkedList<>();
        for (SvgElementHolder element : elements) {
            element.startPosition = svg.indexOf(element.content);
            element.endPosition = element.startPosition + element.content.length();
        }
        Collections.sort(found, new Comparator<SvgElementHolder>() {
            @Override
            public int compare(SvgElementHolder o1, SvgElementHolder o2) {
                return o1.startPosition < o2.startPosition ? -1 : 1;
            }
        });
        return found;
    }

    private static List<SvgElementHolder> findAndParseAllElements(String svg, List<SvgElementHolder> elementList,
                                                                  SvgElementParser parser) {
        String remainingSvg = svg;
        int potentialStart;
        // the index of the opening tag, so that we know which closing tag to look for
        int selectedTag;
        int offsetFromSvgStart = 0;
        int testStart = 0;
        while (testStart != -1) {
            potentialStart = remainingSvg.length();
            selectedTag = 0;
            int tagIndex = 0;
            for (String tagOpen : parser.getSvgTagOpen()) {
                testStart = remainingSvg.indexOf(tagOpen);
                if (testStart != -1 && testStart <= potentialStart) {
                    potentialStart = testStart;
                    selectedTag = tagIndex;
                }
                tagIndex++;
            }

            int potentialEnd = remainingSvg.indexOf(parser.getSvgTagClosed().get(selectedTag));
            if (potentialEnd != -1) {
                int nextSubstringStart = potentialEnd + parser.getSvgTagClosed().get(selectedTag).length();
                parser.iterativeAdd(potentialStart, svg, offsetFromSvgStart, nextSubstringStart, elementList);
                remainingSvg = remainingSvg.substring(nextSubstringStart);
                offsetFromSvgStart += nextSubstringStart;
            } else {
                // todo. Maybe throw an error if end is not found.
                break;
            }
        }
        return elementList;
    }

    private static String parsePatientIdFromLink(SvgElementHolder link) throws Exception {
        String token = "href=\"/bin/data/";
        int idStart = link.content.indexOf(token) + token.length();
        return link.content.substring(idStart, idStart + PATIENT_ID_LENGTH);
    }

    /**
     * Gets a node id from any string (usually SVG id or class attributes).
     *
     * @return -1 if {@link SvgElementHolder#nodeIdTokenStart} is -1 or if fails to find a numeric node id. Otherwise
     * returns the node id
     */
    private static int parseNodeIdFromElement(SvgElementHolder element, String tokenStartString) {
        if (element.nodeIdTokenStart != -1) {
            String nodeIdString = "";
            int readingPosition = element.nodeIdTokenStart + tokenStartString.length();
            Character idChar = element.content.charAt(readingPosition);
            while (Character.isDigit(idChar)) {
                nodeIdString += idChar;
                readingPosition++;
                idChar = element.content.charAt(readingPosition);
            }
            if (StringUtils.isNotBlank(nodeIdString)) {
                return Integer.parseInt(nodeIdString);
            } else {
                return -1;
            }
        }
        return -1;
    }

    /**
     * @param removeCurrent inverts this filter
     */
    private static List<SvgElementHolder> filterByCurrentPatient(List<SvgElementHolder> links, String patientId,
                                                                 boolean removeCurrent) {
        Iterator<SvgElementHolder> iterator = links.iterator();
        while (iterator.hasNext()) {
            SvgElementHolder holder = iterator.next();
            if (removeCurrent) {
                if (StringUtils.equalsIgnoreCase(holder.patientId, patientId)) {
                    iterator.remove();
                }
            } else {
                if (!StringUtils.equalsIgnoreCase(holder.patientId, patientId)) {
                    iterator.remove();
                }
            }
        }
        return links;
    }

    private static Iterable<SvgElementHolder> filterByProbandStatus(Iterable<SvgElementHolder> elements) {
        Iterator<SvgElementHolder> iterator = elements.iterator();
        while (iterator.hasNext()) {
            if (!iterator.next().belongsToProband) {
                iterator.remove();
            }
        }
        return elements;
    }

    /**
     * Concatenates parts of the svg that are not links to patient records
     *
     * @param elements must be a deterministic iterator, returning links in order that they occur in the svg
     * @param svg      must not be null
     * @return modified svg
     */
    private static String applyActionToSvg(Iterator<SvgElementHolder> elements, SvgAction action, String svg,
                                           Iterable<SvgElementHolder>... toUpdate) {
        String parsedSvg = "";
        int splitHead = 0;
        SvgElementHolder holder;
        while (elements.hasNext()) {
            holder = elements.next();
            parsedSvg += svg.substring(splitHead, holder.startPosition);
            parsedSvg += action.getReplacement(holder);
            splitHead = holder.endPosition;
        }
        parsedSvg += svg.substring(splitHead);
        return parsedSvg;
    }

    private static Iterable<SvgElementHolder> shiftSvgElements(Iterable<SvgElementHolder> elements, int shiftBy) {
        for (SvgElementHolder element : elements) {
            int startYPosition = element.content.indexOf(" y=\"");
            if (startYPosition != -1) {
                // accounting for length of ` y="`
                startYPosition += 4;
                int endYPosition = element.content.indexOf('"', startYPosition + 1);
                String yPositionString = element.content.substring(startYPosition, endYPosition);
                double yPosition = Double.parseDouble(yPositionString);

                Double newYPosition = yPosition + shiftBy;
                element.content = element.content.substring(0, startYPosition) + newYPosition.toString()
                        + element.content.substring(endYPosition);
            }
        }
        return elements;
    }

    /**
     * Takes two {@link Iterable}, removes all elements from one that are not present in the other. Element equality is
     * determined by {@link SvgElementHolder}s `nodeId`.
     *
     * @param toSynchronize from which elements will be removed
     * @param authority     the authority that decides which elements should be removed
     * @return toSynchronize
     */
    private static Iterable<SvgElementHolder> synchronizeOnNodeIds(Iterable<SvgElementHolder> toSynchronize,
                                                                   Iterable<SvgElementHolder> authority) {
        Iterator<SvgElementHolder> toSynchronizeIterator = toSynchronize.iterator();
        while (toSynchronizeIterator.hasNext()) {
            SvgElementHolder s = toSynchronizeIterator.next();
            boolean remove = true;
            for (SvgElementHolder a : authority) {
                if (a.nodeId == s.nodeId) {
                    remove = false;
                    break;
                }
            }
            if (remove) {
                toSynchronizeIterator.remove();
            }
        }
        return toSynchronize;
    }

    /**
     * @return svg with the style for current user set to the node with id `currentUserId` and proband style retained
     */
    public static String setPatientStylesInSvg(String svg, String patientId) {
        List<SvgElementHolder> links =
                SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgLinkParser());
        List<SvgElementHolder> nodeShapes =
                SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgNodeShapeParser());

        // would be appropriate to rename these to currentPatientLinks
        links = SvgUpdater.filterByCurrentPatient(links, patientId, false);
        // not ideal, but will likely work fine for a long time - removing stroke from every shape
        Iterable<SvgElementHolder> nodeShapesWithoutStroke = SvgUpdater.removeStrokeWidth(nodeShapes);

        Iterable<SvgElementHolder> probandShape = SvgUpdater.filterByProbandStatus(copyIntoSetIterable(nodeShapes));
        probandShape = addProbandStyle(probandShape);
        // can only be 0 or 1
        Iterable<SvgElementHolder> currentPatientShape =
                SvgUpdater.synchronizeOnNodeIds(copyIntoSetIterable(nodeShapes), links);
        currentPatientShape = addCurrentPatientStyle(currentPatientShape);

        svg = SvgUpdater.applyActionToSvg(nodeShapes.iterator(), new SvgUpdateAction(), svg);
        return svg;
    }

    private static <T> Iterable<T> copyIntoSetIterable(Iterable<T> toCopy) {
        Set<T> copyInto = new HashSet<>();
        for (T toCopyElem : toCopy) {
            copyInto.add(toCopyElem);
        }
        return copyInto;
    }

    private static Iterable<SvgElementHolder> removeStrokeWidth(Iterable<SvgElementHolder> shapes) {
        for (SvgElementHolder shape : shapes) {
            int styleStart = shape.content.indexOf(STROKE_ATTR_TOKEN);
            int styleEnd = shape.content.indexOf('"', styleStart + STROKE_ATTR_TOKEN.length());
            // should throw an error if end is not found, but we are trying to make sure no data is lost
            if (styleStart != -1 && styleEnd != -1) {
                shape.content = shape.content.substring(0, styleStart) + shape.content.substring(styleEnd + 1);
            }
        }
        return shapes;
    }

    /**
     * @param probandShapes usually will be only one, or none
     */
    private static Iterable<SvgElementHolder> addProbandStyle(Iterable<SvgElementHolder> probandShapes) {
        for (SvgElementHolder shape : probandShapes) {
            SvgUpdater.insertStrokeWidth(shape, 2);
        }
        return probandShapes;
    }

    /**
     * @param currentPatientShapes usually will be only one, or none
     */
    private static Iterable<SvgElementHolder> addCurrentPatientStyle(Iterable<SvgElementHolder> currentPatientShapes) {
        for (SvgElementHolder shape : currentPatientShapes) {
            SvgUpdater.insertStrokeWidth(shape, 5);
        }
        return currentPatientShapes;
    }

    private static SvgElementHolder insertStrokeWidth(SvgElementHolder element, double width) {
        if (element.content.contains(STROKE_ATTR_TOKEN)) {
            int tokenStart = element.content.indexOf(STROKE_ATTR_TOKEN);
            int tokenEnd = element.content.indexOf('"', tokenStart + STROKE_ATTR_TOKEN.length());
            element.content = element.content.substring(0, tokenStart + STROKE_ATTR_TOKEN.length()) + width + element
                    .content.substring(tokenEnd);
        } else {
            int closingBracketPos = element.content.indexOf('>');
            element.content = element.content.substring(0, closingBracketPos) + " " + STROKE_ATTR_TOKEN + width + '"' +
                    element.content.substring(closingBracketPos);
        }
        return element;
    }


    private static class SvgElementHolder {
        int startPosition;

        /**
         * Includes the entire closing tag.
         */
        int endPosition;

        int nodeIdTokenStart;

        String content;

        String patientId = "";

        int nodeId;

        /**
         * Could be false even if it does. Must by synchronized with elements that automatically get this assigned.
         */
        boolean belongsToProband = false;
    }

    private static class SvgLinkParser extends SvgElementParser {
        private static final String PEDIGREE_NODE_ID = "pedigreeNodeID=\"";

        @Override
        public List<String> getSvgTagOpen() {
            List list = new LinkedList<String>();
            Collections.addAll(list, "<a");
            return list;
        }

        @Override
        public List<String> getSvgTagClosed() {
            List list = new LinkedList<String>();
            Collections.addAll(list, "</a>");
            return list;
        }

        @Override
        protected String getNodeIdTokenStartString() {
            return PEDIGREE_NODE_ID;
        }

        @Override
        protected boolean test(String testPiece) {
            return testPiece.contains(PEDIGREE_NODE_ID);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder) {
            try {
                holder.patientId = SvgUpdater.parsePatientIdFromLink(holder);
            } catch (Exception ex) {
                // can't do anything
            }
        }
    }

    private static class SvgTextParser extends SvgElementParser {
        private static final String PEDIGREE_NODE_ID = "pedigreeNodeID=\"";

        @Override
        public List<String> getSvgTagOpen() {
            List list = new LinkedList<String>();
            Collections.addAll(list, "<text");
            return list;
        }

        @Override
        public List<String> getSvgTagClosed() {
            List list = new LinkedList<String>();
            Collections.addAll(list, "</text>");
            return list;
        }

        @Override
        protected String getNodeIdTokenStartString() {
            return PEDIGREE_NODE_ID;
        }

        @Override
        protected boolean test(String testPiece) {
            return testPiece.contains(PEDIGREE_NODE_ID);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder) {
            // the pedigree no longer puts the node id into the class name
        }
    }

    private static class SvgNodeShapeParser extends SvgElementParser {
        private static final String TEXT_ID_TOKEN_START = "node-shape-";

        @Override
        public List<String> getSvgTagOpen() {
            List list = new LinkedList<String>();
            Collections.addAll(list, "<rect", "<circle");
            return list;
        }

        @Override
        public List<String> getSvgTagClosed() {
            List list = new LinkedList<String>();
            Collections.addAll(list, "</rect>", "</circle>");
            return list;
        }

        @Override
        protected String getNodeIdTokenStartString() {
            return TEXT_ID_TOKEN_START;
        }

        @Override
        protected boolean test(String testPiece) {
            return testPiece.contains(TEXT_ID_TOKEN_START);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder) {
            holder.belongsToProband = holder.content.contains("isProband=\"true\"");
        }
    }

    // todo. fix name.
    private static abstract class SvgElementParser {
        public abstract List<String> getSvgTagOpen();

        public abstract List<String> getSvgTagClosed();

        protected abstract String getNodeIdTokenStartString();

        protected abstract boolean test(String testPiece);

        protected abstract void performAdditionalOperations(SvgElementHolder holder);

        public void iterativeAdd(int start, String svg, int offset, int nextSubstringStart, List<SvgElementHolder>
                elementList) {
            int absoluteStart = start + offset;
            int absoluteEnd = nextSubstringStart + offset;
            String content = svg.substring(absoluteStart, absoluteEnd);
            if (this.test(content)) {
                SvgElementHolder holder = this.createBasicHolder(absoluteStart, absoluteEnd, content);
                this.performAdditionalOperations(holder);
                elementList.add(holder);
            }
        }

        private SvgElementHolder createBasicHolder(int start, int end, String content) {
            SvgElementHolder holder = new SvgElementHolder();
            holder.startPosition = start;
            holder.endPosition = end;
            holder.content = content;
            holder.nodeIdTokenStart = content.indexOf(this.getNodeIdTokenStartString());
            holder.nodeId = SvgUpdater.parseNodeIdFromElement(holder, this.getNodeIdTokenStartString());
            return holder;
        }
    }

    private static class SvgRemoveAction extends SvgAction {
        @Override
        public String getReplacement(SvgElementHolder holder) {
            return "";
        }
    }

    private static class SvgUpdateAction extends SvgAction {
        @Override
        public String getReplacement(SvgElementHolder holder) {
            return holder.content;
        }
    }

    private static abstract class SvgAction {
        public abstract String getReplacement(SvgElementHolder holder);
    }
}
