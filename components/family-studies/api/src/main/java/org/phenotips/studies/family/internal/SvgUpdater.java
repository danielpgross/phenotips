package org.phenotips.studies.family.internal;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

/**
 * Tools for updating the SVG generated by the pedigree.
 */
public class SvgUpdater
{
    private static final int PATIENT_ID_LENGTH = 8;

    /** The number of pixels to shift text when a link is removed. */
    private static final int VERTICAL_SHIFT = -22;

    public static String removeLinks(String svg, String currentPatientId)
    {
        // must be a list, so that the iterator will return links in order they occur
        List<SvgElementHolder> links =
            SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgLinkAdder());
        Iterable<SvgElementHolder> labels =
            SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgTextAdder());

        links = SvgUpdater.filterByCurrentPatient(links, currentPatientId, true);
        labels = SvgUpdater.synchronizeOnNodeIds(labels, links);
        labels = SvgUpdater.shiftSvgElements(labels, SvgUpdater.VERTICAL_SHIFT);

        svg = SvgUpdater.applyActionToSvg(links.iterator(), new SvgRemoveAction(), svg);
        svg = SvgUpdater.applyActionToSvg(labels.iterator(), new SvgUpdateAction(), svg);
        return svg;
    }

    private static List<SvgElementHolder> findAndParseAllElements(String svg, List<SvgElementHolder> elementList,
        SvgElementAdder adder)
    {
        String remainingSvg = svg;
        int potentialStart = remainingSvg.indexOf(adder.getSvgTagOpen());
        int offsetFromSvgStart = 0;
        while (potentialStart != -1) {
            int potentialEnd = remainingSvg.indexOf(adder.getSvgTagClosed());
            if (potentialEnd != -1) {
                int nextSubstringStart =
                    adder.iterativeAdd(potentialStart, potentialEnd, svg, offsetFromSvgStart, elementList);
                remainingSvg = remainingSvg.substring(nextSubstringStart);
                offsetFromSvgStart += nextSubstringStart;
            } else {
                // todo. Maybe throw an error if end is not found.
                break;
            }
            potentialStart = remainingSvg.indexOf(adder.getSvgTagOpen());
        }
        return elementList;
    }

    private static String parsePatientIdFromLink(SvgElementHolder link) throws Exception
    {
        if (link.idTokenStart == -1) {
            throw new Exception("The link does not contain a patient ID");
        }
        String idSubstring = link.content.substring(link.idTokenStart);
        idSubstring = idSubstring.substring(0, idSubstring.indexOf('"'));
        int idStart = idSubstring.indexOf("patient_") + 8;
        return link.content.substring(idStart, idStart + PATIENT_ID_LENGTH);
    }

    private static int parseNodeIdFromElement(SvgElementHolder element, String tokenStartString)
    {
        if (element.idTokenStart != -1) {
            String nodeIdString = "";
            int readingPosition = element.idTokenStart + tokenStartString.length();
            Character idChar = element.content.charAt(readingPosition);
            while (Character.isDigit(idChar)) {
                nodeIdString += idChar;
                readingPosition++;
                idChar = element.content.charAt(readingPosition);
            }
            return Integer.parseInt(nodeIdString);
        }
        return -1;
    }

    private static List<SvgElementHolder> filterByCurrentPatient(List<SvgElementHolder> links, String patientId, boolean removeCurrent)
    {
        for (SvgElementHolder holder : links) {
            if (removeCurrent) {
                if (StringUtils.equalsIgnoreCase(holder.patientId, patientId)) {
                    links.remove(holder);
                }
            } else {
                if (!StringUtils.equalsIgnoreCase(holder.patientId, patientId)) {
                    links.remove(holder);
                }
            }
        }
        return links;
    }

    /**
     * Concatenates parts of the svg that are not links to patient records
     *
     * @param elements must be a deterministic iterator, returning links in order that they occur in the svg
     * @param svg must not be null
     * @return modified svg
     */
    private static String applyActionToSvg(Iterator<SvgElementHolder> elements, SvgAction action, String svg)
    {
        String parsedSvg = "";
        int splitHead = 0;
        SvgElementHolder holder;
        while (elements.hasNext()) {
            holder = elements.next();
            parsedSvg += svg.substring(splitHead, holder.startPosition);
            parsedSvg += action.getReplacement(holder);
            splitHead = holder.endPosition;
        }
        parsedSvg += svg.substring(splitHead);
        return parsedSvg;
    }

    private static Iterable<SvgElementHolder> shiftSvgElements(Iterable<SvgElementHolder> elements, int shiftBy)
    {
        for (SvgElementHolder element : elements) {
            int startYPosition = element.content.indexOf(" y=\"");
            if (startYPosition != -1) {
                // accounting for length of ` y="`
                startYPosition += 4;
                int endYPosition = element.content.indexOf('"', startYPosition + 1);
                String yPositionString = element.content.substring(startYPosition, endYPosition);
                double yPosition = Double.parseDouble(yPositionString);

                Double newYPosition = yPosition + shiftBy;
                element.content = element.content.substring(0, startYPosition) + newYPosition.toString()
                    + element.content.substring(endYPosition);
            }
        }
        return elements;
    }

    /**
     * Takes two {@link Iterable}, removes all elements from one that are not present in the other. Element equality is
     * determined by {@link SvgElementHolder}s `nodeId`.
     *
     * @param toSynchronize from which elements will be removed
     * @param authority the authority that decides which elements should be removed
     * @return toSynchronize
     */
    private static Iterable<SvgElementHolder> synchronizeOnNodeIds(Iterable<SvgElementHolder> toSynchronize,
        Iterable<SvgElementHolder> authority)
    {
        Iterator<SvgElementHolder> toSynchronizeIterator = toSynchronize.iterator();
        while (toSynchronizeIterator.hasNext()) {
            SvgElementHolder s = toSynchronizeIterator.next();
            boolean remove = true;
            for (SvgElementHolder a : authority) {
                if (a.nodeId == s.nodeId) {
                    remove = false;
                    break;
                }
            }
            if (remove) {
                toSynchronizeIterator.remove();
            }
        }
        return toSynchronize;
    }

    /**
     * @return svg with the style for current user set to the node with id `currentUserId`
     */
    public static String setAsCurrentPatientInSvg(String svg, String patientId) {
        List<SvgElementHolder> links =
            SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgLinkAdder());
        Iterable<SvgElementHolder> nodeShapes =
            SvgUpdater.findAndParseAllElements(svg, new LinkedList<SvgElementHolder>(), new SvgNodeShapeAdder());

        links = SvgUpdater.filterByCurrentPatient(links, patientId, false);
        nodeShapes = SvgUpdater.removeStrokeWidth(nodeShapes);

        // can only be 0 or 1
        Iterable<SvgElementHolder> currentPatientShape = SvgUpdater.synchronizeOnNodeIds(nodeShapes, links);

        svg = SvgUpdater.applyActionToSvg(nodeShapes.iterator(), new SvgUpdateAction(), svg);
        return svg;
    }

    private static Iterable<SvgElementHolder> removeStrokeWidth(Iterable<SvgElementHolder> shapes) {
        for (SvgElementHolder shape : shapes) {
            int styleStart = shape.content.indexOf("stroke-width=\"");
            int styleEnd = shape.content.indexOf(styleStart, '"');
            shape.content = shape.content.substring(0, styleStart) + shape.content.substring(styleEnd + 1);
        }
        return shapes;
    }

    /**
     * @param probandShapes usually will be only one, or none
     */
    private static Iterable<SvgElementHolder> addProbandStyle(Iterable<SvgElementHolder> probandShapes) {

        return probandShapes;
    }

    /**
     * @param currentPatientShapes usually will be only one, or none
     */
    private static Iterable<SvgElementHolder> addCurrentPatientStyle(Iterable<SvgElementHolder> currentPatientShapes) {

        return currentPatientShapes;
    }

    private static SvgElementHolder insertStrokeWidth(SvgElementHolder element, double width)
    {
        int closingBracketPos = element.content.indexOf('>');
        element.content = element.content.substring(0, closingBracketPos) + " stroke-width=\"" + width + '"' + element.content.substring(closingBracketPos);
        return element;
    }


    private static class SvgElementHolder
    {
        int startPosition;

        /** Includes the entire closing tag. */
        int endPosition;

        int idTokenStart;

        String content;

        String patientId = "";

        int nodeId;
    }

    private static class SvgLinkAdder extends SvgElementAdder
    {
        private static final String LINK_ID_TOKEN_START = "link_id_";

        @Override public String getSvgTagOpen()
        {
            return "<a";
        }

        @Override public String getSvgTagClosed()
        {
            return "</a>";
        }

        @Override protected String getIdTokenStartString()
        {
            return LINK_ID_TOKEN_START;
        }

        @Override
        protected boolean test(String testPiece)
        {
            return testPiece.contains(LINK_ID_TOKEN_START);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder)
        {
            try {
                holder.patientId = SvgUpdater.parsePatientIdFromLink(holder);
            } catch (Exception ex) {
                // can't do anything
            }
        }
    }
    private static class SvgTextAdder extends SvgElementAdder
    {
        private static final String TEXT_ID_TOKEN_START = "text_id_";

        @Override public String getSvgTagOpen()
        {
            return "<text";
        }

        @Override public String getSvgTagClosed()
        {
            return "</text>";
        }

        @Override protected String getIdTokenStartString()
        {
            return TEXT_ID_TOKEN_START;
        }

        @Override
        protected boolean test(String testPiece)
        {
            return testPiece.contains(TEXT_ID_TOKEN_START);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder)
        {
        }
    }
    private static class SvgNodeShapeAdder extends SvgElementAdder
    {
        private static final String TEXT_ID_TOKEN_START = "node-shape-";

        @Override public String getSvgTagOpen()
        {
            return "<rect";
        }

        @Override public String getSvgTagClosed()
        {
            return "</rect>";
        }

        @Override protected String getIdTokenStartString()
        {
            return TEXT_ID_TOKEN_START;
        }

        @Override
        protected boolean test(String testPiece)
        {
            return testPiece.contains(TEXT_ID_TOKEN_START);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder)
        {}
    }

    // todo. fix name.
    private static abstract class SvgElementAdder
    {
        public abstract String getSvgTagOpen();

        public abstract String getSvgTagClosed();

        protected abstract String getIdTokenStartString();

        protected abstract boolean test(String testPiece);

        protected abstract void performAdditionalOperations(SvgElementHolder holder);

        public int iterativeAdd(int start, int end, String svg, int offset,
            List<SvgElementHolder> elementList)
        {
            int nextSubstringStart = end + this.getSvgTagClosed().length();
            int absoluteStart = start + offset;
            int absoluteEnd = nextSubstringStart + offset;
            String content = svg.substring(absoluteStart, absoluteEnd);
            if (this.test(content)) {
                SvgElementHolder holder = this.createBasicHolder(absoluteStart, absoluteEnd, content);
                this.performAdditionalOperations(holder);
                elementList.add(holder);
            }
            return nextSubstringStart;
        }

        private SvgElementHolder createBasicHolder(int start, int end, String content)
        {
            SvgElementHolder holder = new SvgElementHolder();
            holder.startPosition = start;
            holder.endPosition = end;
            holder.content = content;
            holder.idTokenStart = content.indexOf(this.getIdTokenStartString());
            holder.nodeId = SvgUpdater.parseNodeIdFromElement(holder, this.getIdTokenStartString());
            return holder;
        }
    }

    private static class SvgRemoveAction extends SvgAction
    {
        @Override public String getReplacement(SvgElementHolder holder)
        {
            return "";
        }
    }

    private static class SvgUpdateAction extends SvgAction
    {
        @Override public String getReplacement(SvgElementHolder holder)
        {
            return holder.content;
        }
    }

    private static abstract class SvgAction
    {
        public abstract String getReplacement(SvgElementHolder holder);
    }
}
